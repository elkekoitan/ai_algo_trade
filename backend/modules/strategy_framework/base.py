"""
Base Strategy Classes and Interfaces

Provides abstract base classes and interfaces that all trading strategies must implement.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
from dataclasses import dataclass
from enum import Enum
import pandas as pd
from pydantic import BaseModel, Field


class SignalType(str, Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    CLOSE_BUY = "close_buy"
    CLOSE_SELL = "close_sell"
    CLOSE_ALL = "close_all"
    MODIFY = "modify"
    NONE = "none"


class SignalStrength(str, Enum):
    """Signal strength levels"""
    WEAK = "weak"
    MEDIUM = "medium"
    STRONG = "strong"
    VERY_STRONG = "very_strong"


@dataclass
class MarketData:
    """Market data container"""
    symbol: str
    timeframe: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float
    bid: float
    ask: float
    spread: float
    additional_data: Dict[str, Any] = None


class StrategySignal(BaseModel):
    """Trading signal generated by strategy"""
    signal_type: SignalType
    symbol: str
    strength: SignalStrength
    confidence: float = Field(ge=0, le=1)
    
    # Trade parameters
    lot_size: Optional[float] = None
    entry_price: Optional[float] = None
    take_profit: Optional[float] = None
    stop_loss: Optional[float] = None
    
    # Additional metadata
    reason: str = ""
    metadata: Dict[str, Any] = Field(default_factory=dict)
    timestamp: datetime = Field(default_factory=datetime.now)


class ExecutionResult(BaseModel):
    """Result of trade execution"""
    success: bool
    order_id: Optional[str] = None
    executed_price: Optional[float] = None
    executed_volume: Optional[float] = None
    commission: Optional[float] = None
    error_message: Optional[str] = None
    execution_time_ms: float = 0
    metadata: Dict[str, Any] = Field(default_factory=dict)


class StrategyParameters(BaseModel):
    """Base strategy parameters"""
    # Risk management
    max_positions: int = Field(1, ge=1, description="Maximum concurrent positions")
    risk_per_trade: float = Field(0.02, ge=0.001, le=0.1, description="Risk per trade as fraction")
    max_daily_loss: float = Field(0.05, ge=0.01, le=0.2, description="Max daily loss as fraction")
    
    # Position management
    use_stop_loss: bool = Field(True, description="Enable stop loss")
    use_take_profit: bool = Field(True, description="Enable take profit")
    trailing_stop: bool = Field(False, description="Enable trailing stop")
    
    # Time filters
    trading_hours: Dict[str, Any] = Field(default_factory=dict, description="Trading hour restrictions")
    
    # Additional parameters (strategy-specific)
    custom_params: Dict[str, Any] = Field(default_factory=dict)


class OptimizationResult(BaseModel):
    """Result of strategy optimization"""
    original_params: Dict[str, Any]
    optimized_params: Dict[str, Any]
    improvement_metrics: Dict[str, float]
    backtest_results: Dict[str, Any]
    optimization_time_seconds: float
    confidence_score: float = Field(ge=0, le=1)


class IStrategy(ABC):
    """
    Abstract base interface for all trading strategies.
    All strategies must implement these methods.
    """
    
    @abstractmethod
    async def initialize(self, config: Dict[str, Any]) -> None:
        """
        Initialize strategy with configuration.
        Called once when strategy is created.
        
        Args:
            config: Strategy configuration dictionary
        """
        pass
    
    @abstractmethod
    async def analyze(self, market_data: MarketData) -> StrategySignal:
        """
        Analyze market data and generate trading signal.
        This is the core logic of the strategy.
        
        Args:
            market_data: Current market data
            
        Returns:
            Trading signal or NONE signal
        """
        pass
    
    @abstractmethod
    async def execute(self, signal: StrategySignal) -> ExecutionResult:
        """
        Execute the trading signal.
        
        Args:
            signal: Trading signal to execute
            
        Returns:
            Execution result with success status
        """
        pass
    
    @abstractmethod
    async def optimize(self, historical_data: pd.DataFrame) -> OptimizationResult:
        """
        Optimize strategy parameters using historical data.
        
        Args:
            historical_data: Historical market data for backtesting
            
        Returns:
            Optimization result with new parameters
        """
        pass
    
    @abstractmethod
    def get_parameters(self) -> StrategyParameters:
        """Get current strategy parameters"""
        pass
    
    @abstractmethod
    def set_parameters(self, params: StrategyParameters) -> None:
        """Update strategy parameters"""
        pass
    
    @abstractmethod
    def get_info(self) -> Dict[str, Any]:
        """
        Get strategy information.
        
        Returns:
            Dictionary with strategy metadata
        """
        pass
    
    @abstractmethod
    async def on_tick(self, tick_data: Dict[str, Any]) -> None:
        """
        Handle real-time tick data.
        Optional method for high-frequency strategies.
        
        Args:
            tick_data: Real-time tick data
        """
        pass
    
    @abstractmethod
    async def on_position_opened(self, position: Dict[str, Any]) -> None:
        """
        Callback when a position is opened.
        
        Args:
            position: Position details
        """
        pass
    
    @abstractmethod
    async def on_position_closed(self, position: Dict[str, Any], pnl: float) -> None:
        """
        Callback when a position is closed.
        
        Args:
            position: Position details
            pnl: Profit/loss of the position
        """
        pass
    
    @abstractmethod
    async def cleanup(self) -> None:
        """
        Cleanup strategy resources.
        Called when strategy is stopped.
        """
        pass


class StrategyBase(IStrategy):
    """
    Base implementation of IStrategy with common functionality.
    Concrete strategies should inherit from this class.
    """
    
    def __init__(self, strategy_id: str, event_bus=None):
        self.strategy_id = strategy_id
        self.event_bus = event_bus
        self.parameters = StrategyParameters()
        self.is_initialized = False
        self.is_active = False
        self.open_positions = []
        self.performance_metrics = {}
        
    async def initialize(self, config: Dict[str, Any]) -> None:
        """Base initialization logic"""
        self.config = config
        
        # Load parameters from config
        if "parameters" in config:
            self.parameters = StrategyParameters(**config["parameters"])
        
        # Subscribe to relevant events
        if self.event_bus:
            await self._setup_event_subscriptions()
        
        self.is_initialized = True
        
    async def _setup_event_subscriptions(self):
        """Setup event bus subscriptions"""
        # Subscribe to market events
        self.event_bus.subscribe(
            f"market.{self.strategy_id}.tick",
            self.on_tick
        )
        
        # Subscribe to position events
        self.event_bus.subscribe(
            f"position.{self.strategy_id}.opened",
            self.on_position_opened
        )
        
        self.event_bus.subscribe(
            f"position.{self.strategy_id}.closed",
            self.on_position_closed
        )
    
    def get_parameters(self) -> StrategyParameters:
        """Get current parameters"""
        return self.parameters
    
    def set_parameters(self, params: StrategyParameters) -> None:
        """Set parameters with validation"""
        self.parameters = params
        
        # Emit parameter update event
        if self.event_bus:
            self.event_bus.emit(
                f"strategy.{self.strategy_id}.parameters_updated",
                {"parameters": params.dict()}
            )
    
    def get_info(self) -> Dict[str, Any]:
        """Get strategy information"""
        return {
            "strategy_id": self.strategy_id,
            "class_name": self.__class__.__name__,
            "is_initialized": self.is_initialized,
            "is_active": self.is_active,
            "open_positions": len(self.open_positions),
            "parameters": self.parameters.dict()
        }
    
    async def on_tick(self, tick_data: Dict[str, Any]) -> None:
        """Default tick handler - can be overridden"""
        pass
    
    async def on_position_opened(self, position: Dict[str, Any]) -> None:
        """Default position opened handler"""
        self.open_positions.append(position)
        
    async def on_position_closed(self, position: Dict[str, Any], pnl: float) -> None:
        """Default position closed handler"""
        # Remove from open positions
        self.open_positions = [
            p for p in self.open_positions 
            if p.get("id") != position.get("id")
        ]
        
        # Update performance metrics
        if "total_pnl" not in self.performance_metrics:
            self.performance_metrics["total_pnl"] = 0
        self.performance_metrics["total_pnl"] += pnl
        
    async def cleanup(self) -> None:
        """Default cleanup implementation"""
        self.is_active = False
        
        # Unsubscribe from events
        if self.event_bus:
            self.event_bus.unsubscribe_all(f"market.{self.strategy_id}.*")
            self.event_bus.unsubscribe_all(f"position.{self.strategy_id}.*")
    
    # Helper methods for concrete strategies
    
    def _calculate_position_size(self, account_balance: float, stop_loss_pips: float) -> float:
        """Calculate position size based on risk management"""
        risk_amount = account_balance * self.parameters.risk_per_trade
        position_size = risk_amount / stop_loss_pips
        return round(position_size, 2)
    
    def _check_trading_hours(self) -> bool:
        """Check if current time is within trading hours"""
        if not self.parameters.trading_hours:
            return True
            
        # Implementation depends on trading hours format
        current_hour = datetime.now().hour
        start_hour = self.parameters.trading_hours.get("start", 0)
        end_hour = self.parameters.trading_hours.get("end", 24)
        
        return start_hour <= current_hour < end_hour
    
    def _check_max_positions(self) -> bool:
        """Check if max positions limit is reached"""
        return len(self.open_positions) < self.parameters.max_positions
    
    async def _emit_signal(self, signal: StrategySignal):
        """Emit signal to event bus"""
        if self.event_bus:
            self.event_bus.emit(
                f"strategy.{self.strategy_id}.signal",
                signal.dict()
            )
    
    async def _log_performance(self, metric: str, value: float):
        """Log performance metric"""
        self.performance_metrics[metric] = value
        
        if self.event_bus:
            self.event_bus.emit(
                f"strategy.{self.strategy_id}.performance",
                {
                    "metric": metric,
                    "value": value,
                    "timestamp": datetime.now().isoformat()
                }
            ) 