"""
MQL5 Code Generator for Strategy Whisperer
"""

from typing import Dict, List, Optional, Any
from datetime import datetime
import re

from backend.core.logger import get_logger
from .models import (
    StrategyParameters, TradingCondition, MQL5Code,
    IndicatorType, RiskType, OrderType
)

logger = get_logger(__name__)


class MQL5Generator:
    """Generate optimized MQL5 code from strategy parameters"""
    
    def __init__(self):
        self.templates = self._load_templates()
        self.indicator_functions = self._create_indicator_functions()
    
    def _load_templates(self) -> Dict[str, str]:
        """Load MQL5 code templates"""
        return {
            "header": """//+------------------------------------------------------------------+
//|                                                {name}.mq5         |
//|                                    Generated by Strategy Whisperer |
//|                                             {timestamp}           |
//+------------------------------------------------------------------+
#property copyright "AI Algo Trade - Strategy Whisperer"
#property link      "https://aialgotrade.com"
#property version   "{version}"
#property strict

// Input parameters
input int      MagicNumber = {magic_number};     // Magic number
input double   RiskPercent = {risk_value};        // Risk per trade (%)
input double   StopLoss = {stop_loss};            // Stop Loss (pips)
input double   TakeProfit = {take_profit};        // Take Profit (pips)
input int      MaxPositions = {max_positions};    // Maximum positions
""",
            
            "globals": """
// Global variables
CTrade trade;
CPositionInfo position;
COrderInfo order;
CSymbolInfo symbol;

// Indicator handles
{indicator_handles}

// Buffers
{indicator_buffers}

// Strategy variables
datetime lastBarTime = 0;
int totalPositions = 0;
""",
            
            "init": """
//+------------------------------------------------------------------+
//| Expert initialization function                                    |
//+------------------------------------------------------------------+
int OnInit()
{{
   // Set magic number
   trade.SetExpertMagicNumber(MagicNumber);
   
   // Initialize symbol
   if(!symbol.Name(_Symbol))
   {{
      Print("Failed to initialize symbol");
      return(INIT_FAILED);
   }}
   
   // Initialize indicators
{indicator_init}
   
   // Validation
   if(!ValidateInputs())
   {{
      Print("Invalid input parameters");
      return(INIT_FAILED);
   }}
   
   Print("{name} initialized successfully");
   return(INIT_SUCCEEDED);
}}
""",
            
            "deinit": """
//+------------------------------------------------------------------+
//| Expert deinitialization function                                  |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{{
   // Release indicator handles
{indicator_release}
   
   Print("{name} deinitialized");
}}
""",
            
            "tick": """
//+------------------------------------------------------------------+
//| Expert tick function                                              |
//+------------------------------------------------------------------+
void OnTick()
{{
   // Check for new bar
   if(!IsNewBar()) return;
   
   // Update symbol info
   if(!symbol.RefreshRates())
   {{
      Print("Failed to refresh rates");
      return;
   }}
   
   // Count current positions
   CountPositions();
   
   // Check entry conditions
   if(totalPositions < MaxPositions)
   {{
      CheckEntrySignals();
   }}
   
   // Check exit conditions
   if(totalPositions > 0)
   {{
      CheckExitSignals();
   }}
   
   // Manage positions
   ManagePositions();
}}
""",
            
            "entry_logic": """
//+------------------------------------------------------------------+
//| Check entry signals                                               |
//+------------------------------------------------------------------+
void CheckEntrySignals()
{{
   // Get indicator values
{get_indicator_values}
   
   // Check buy conditions
   bool buySignal = {buy_conditions};
   
   // Check sell conditions
   bool sellSignal = {sell_conditions};
   
   // Execute trades
   if(buySignal && !sellSignal)
   {{
      OpenBuyPosition();
   }}
   else if(sellSignal && !buySignal)
   {{
      OpenSellPosition();
   }}
}}
""",
            
            "position_management": """
//+------------------------------------------------------------------+
//| Open buy position                                                 |
//+------------------------------------------------------------------+
void OpenBuyPosition()
{{
   double lotSize = CalculateLotSize();
   double sl = CalculateStopLoss(ORDER_TYPE_BUY);
   double tp = CalculateTakeProfit(ORDER_TYPE_BUY);
   
   if(trade.Buy(lotSize, _Symbol, 0, sl, tp, "Buy Signal"))
   {{
      Print("Buy position opened successfully");
   }}
   else
   {{
      Print("Failed to open buy position: ", trade.ResultRetcodeDescription());
   }}
}}

//+------------------------------------------------------------------+
//| Open sell position                                                |
//+------------------------------------------------------------------+
void OpenSellPosition()
{{
   double lotSize = CalculateLotSize();
   double sl = CalculateStopLoss(ORDER_TYPE_SELL);
   double tp = CalculateTakeProfit(ORDER_TYPE_SELL);
   
   if(trade.Sell(lotSize, _Symbol, 0, sl, tp, "Sell Signal"))
   {{
      Print("Sell position opened successfully");
   }}
   else
   {{
      Print("Failed to open sell position: ", trade.ResultRetcodeDescription());
   }}
}}
""",
            
            "utility_functions": """
//+------------------------------------------------------------------+
//| Calculate lot size based on risk                                  |
//+------------------------------------------------------------------+
double CalculateLotSize()
{{
{lot_calculation}
}}

//+------------------------------------------------------------------+
//| Calculate stop loss                                               |
//+------------------------------------------------------------------+
double CalculateStopLoss(ENUM_ORDER_TYPE orderType)
{{
   double sl = 0;
   double point = symbol.Point();
   
   if(orderType == ORDER_TYPE_BUY)
   {{
      sl = symbol.Ask() - StopLoss * point * 10;
   }}
   else
   {{
      sl = symbol.Bid() + StopLoss * point * 10;
   }}
   
   return NormalizeDouble(sl, symbol.Digits());
}}

//+------------------------------------------------------------------+
//| Calculate take profit                                             |
//+------------------------------------------------------------------+
double CalculateTakeProfit(ENUM_ORDER_TYPE orderType)
{{
   double tp = 0;
   double point = symbol.Point();
   
   if(orderType == ORDER_TYPE_BUY)
   {{
      tp = symbol.Ask() + TakeProfit * point * 10;
   }}
   else
   {{
      tp = symbol.Bid() - TakeProfit * point * 10;
   }}
   
   return NormalizeDouble(tp, symbol.Digits());
}}

//+------------------------------------------------------------------+
//| Check for new bar                                                 |
//+------------------------------------------------------------------+
bool IsNewBar()
{{
   datetime currentBarTime = iTime(_Symbol, {timeframe}, 0);
   
   if(currentBarTime != lastBarTime)
   {{
      lastBarTime = currentBarTime;
      return true;
   }}
   
   return false;
}}

//+------------------------------------------------------------------+
//| Count current positions                                           |
//+------------------------------------------------------------------+
void CountPositions()
{{
   totalPositions = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {{
      if(position.SelectByIndex(i))
      {{
         if(position.Symbol() == _Symbol && position.Magic() == MagicNumber)
         {{
            totalPositions++;
         }}
      }}
   }}
}}

//+------------------------------------------------------------------+
//| Validate input parameters                                         |
//+------------------------------------------------------------------+
bool ValidateInputs()
{{
   if(RiskPercent <= 0 || RiskPercent > 10)
   {{
      Print("Invalid risk percent: ", RiskPercent);
      return false;
   }}
   
   if(StopLoss < 5)
   {{
      Print("Stop loss too small: ", StopLoss);
      return false;
   }}
   
   return true;
}}
"""
        }
    
    def _create_indicator_functions(self) -> Dict[str, Dict[str, str]]:
        """Create indicator-specific code snippets"""
        return {
            "RSI": {
                "handle": "int rsiHandle;",
                "buffer": "double rsiBuffer[];",
                "init": "rsiHandle = iRSI(_Symbol, {timeframe}, {period}, PRICE_CLOSE);",
                "release": "IndicatorRelease(rsiHandle);",
                "get_value": "CopyBuffer(rsiHandle, 0, 1, 1, rsiBuffer);",
                "value": "rsiBuffer[0]"
            },
            "MACD": {
                "handle": "int macdHandle;",
                "buffer": "double macdMain[], macdSignal[];",
                "init": "macdHandle = iMACD(_Symbol, {timeframe}, {fast}, {slow}, {signal}, PRICE_CLOSE);",
                "release": "IndicatorRelease(macdHandle);",
                "get_value": "CopyBuffer(macdHandle, 0, 1, 1, macdMain);\n   CopyBuffer(macdHandle, 1, 1, 1, macdSignal);",
                "value": "macdMain[0]",
                "signal_value": "macdSignal[0]"
            },
            "MA": {
                "handle": "int maHandle;",
                "buffer": "double maBuffer[];",
                "init": "maHandle = iMA(_Symbol, {timeframe}, {period}, 0, MODE_SMA, PRICE_CLOSE);",
                "release": "IndicatorRelease(maHandle);",
                "get_value": "CopyBuffer(maHandle, 0, 1, 1, maBuffer);",
                "value": "maBuffer[0]"
            },
            "EMA": {
                "handle": "int emaHandle;",
                "buffer": "double emaBuffer[];",
                "init": "emaHandle = iMA(_Symbol, {timeframe}, {period}, 0, MODE_EMA, PRICE_CLOSE);",
                "release": "IndicatorRelease(emaHandle);",
                "get_value": "CopyBuffer(emaHandle, 0, 1, 1, emaBuffer);",
                "value": "emaBuffer[0]"
            }
        }
    
    async def generate_code(self, params: StrategyParameters) -> MQL5Code:
        """Generate complete MQL5 code from parameters"""
        try:
            # Prepare template variables
            template_vars = {
                "name": params.name,
                "timestamp": datetime.now().strftime("%Y.%m.%d %H:%M"),
                "version": "1.0.0",
                "magic_number": params.magic_number,
                "risk_value": params.risk_value,
                "stop_loss": params.stop_loss_pips or 50,
                "take_profit": params.take_profit_pips or 100,
                "max_positions": params.max_positions,
                "timeframe": self._get_mql5_timeframe(params.timeframe)
            }
            
            # Generate code sections
            header = self.templates["header"].format(**template_vars)
            
            # Generate indicator code
            indicator_code = self._generate_indicator_code(params)
            
            # Generate entry/exit logic
            entry_logic = self._generate_entry_logic(params)
            exit_logic = self._generate_exit_logic(params)
            
            # Generate risk management
            risk_code = self._generate_risk_management(params)
            
            # Combine all sections
            full_code = self._combine_code_sections(
                header, indicator_code, entry_logic, 
                exit_logic, risk_code, template_vars
            )
            
            # Validate and optimize
            syntax_errors = self._validate_syntax(full_code)
            optimization_hints = self._generate_optimization_hints(params)
            
            return MQL5Code(
                strategy_id=params.name,
                code=full_code,
                version="1.0.0",
                estimated_lines=len(full_code.split('\n')),
                includes=["Trade\\Trade.mqh", "Trade\\PositionInfo.mqh"],
                external_dependencies=[],
                syntax_valid=len(syntax_errors) == 0,
                syntax_errors=syntax_errors,
                warnings=[],
                optimization_suggestions=optimization_hints,
                performance_score=self._calculate_performance_score(params)
            )
            
        except Exception as e:
            logger.error(f"Error generating MQL5 code: {str(e)}")
            raise
    
    def _get_mql5_timeframe(self, timeframe: TimeFrame) -> str:
        """Convert TimeFrame enum to MQL5 period"""
        timeframe_map = {
            TimeFrame.M1: "PERIOD_M1",
            TimeFrame.M5: "PERIOD_M5",
            TimeFrame.M15: "PERIOD_M15",
            TimeFrame.M30: "PERIOD_M30",
            TimeFrame.H1: "PERIOD_H1",
            TimeFrame.H4: "PERIOD_H4",
            TimeFrame.D1: "PERIOD_D1",
            TimeFrame.W1: "PERIOD_W1",
            TimeFrame.MN1: "PERIOD_MN1"
        }
        return timeframe_map.get(timeframe, "PERIOD_H1")
    
    def _generate_indicator_code(self, params: StrategyParameters) -> Dict[str, str]:
        """Generate indicator-specific code"""
        handles = []
        buffers = []
        inits = []
        releases = []
        get_values = []
        
        # Get unique indicators
        indicators = set()
        for condition in params.entry_conditions + params.exit_conditions:
            indicators.add(condition.indicator)
        
        # Generate code for each indicator
        for indicator in indicators:
            if indicator.value in self.indicator_functions:
                func = self.indicator_functions[indicator.value]
                
                # Get parameters from first condition using this indicator
                indicator_params = {}
                for cond in params.entry_conditions + params.exit_conditions:
                    if cond.indicator == indicator:
                        indicator_params = cond.parameters
                        break
                
                # Format code with parameters
                handles.append(func["handle"])
                buffers.append(func["buffer"])
                
                init_code = func["init"].format(
                    timeframe=self._get_mql5_timeframe(params.timeframe),
                    **indicator_params
                )
                inits.append(init_code)
                
                releases.append(func["release"])
                get_values.append(func["get_value"])
        
        return {
            "handles": "\n".join(handles),
            "buffers": "\n".join(buffers),
            "inits": "\n   ".join(inits),
            "releases": "\n   ".join(releases),
            "get_values": "\n   ".join(get_values)
        }
    
    def _generate_entry_logic(self, params: StrategyParameters) -> str:
        """Generate entry condition logic"""
        buy_conditions = []
        sell_conditions = []
        
        for condition in params.entry_conditions:
            indicator_name = condition.indicator.value
            
            if indicator_name in self.indicator_functions:
                value_ref = self.indicator_functions[indicator_name]["value"]
                
                # Generate condition string
                if condition.comparison in [">", "<", "==", ">=", "<="]:
                    cond_str = f"{value_ref} {condition.comparison} {condition.value}"
                elif condition.comparison == "crosses_above":
                    cond_str = f"({value_ref} > {condition.value} && prev_{indicator_name} <= {condition.value})"
                elif condition.comparison == "crosses_below":
                    cond_str = f"({value_ref} < {condition.value} && prev_{indicator_name} >= {condition.value})"
                else:
                    cond_str = "true"  # Default
                
                # Determine if buy or sell condition
                if indicator_name == "RSI":
                    if condition.value < 50:  # Oversold = buy
                        buy_conditions.append(cond_str)
                    else:  # Overbought = sell
                        sell_conditions.append(cond_str)
                else:
                    # Default: use as buy condition
                    buy_conditions.append(cond_str)
        
        # Join conditions with logic operator
        logic_op = " && " if params.entry_logic == "AND" else " || "
        buy_logic = logic_op.join(buy_conditions) if buy_conditions else "false"
        sell_logic = logic_op.join(sell_conditions) if sell_conditions else "false"
        
        return {
            "buy_conditions": buy_logic,
            "sell_conditions": sell_logic
        }
    
    def _generate_exit_logic(self, params: StrategyParameters) -> str:
        """Generate exit condition logic"""
        # Similar to entry logic but for exits
        exit_conditions = []
        
        for condition in params.exit_conditions:
            indicator_name = condition.indicator.value
            
            if indicator_name in self.indicator_functions:
                value_ref = self.indicator_functions[indicator_name]["value"]
                
                if condition.comparison in [">", "<", "==", ">=", "<="]:
                    cond_str = f"{value_ref} {condition.comparison} {condition.value}"
                else:
                    cond_str = "true"
                
                exit_conditions.append(cond_str)
        
        logic_op = " && " if params.exit_logic == "AND" else " || "
        return logic_op.join(exit_conditions) if exit_conditions else "false"
    
    def _generate_risk_management(self, params: StrategyParameters) -> str:
        """Generate risk management code"""
        if params.risk_type == RiskType.FIXED_LOT:
            lot_calc = f"return {params.risk_value};"
        elif params.risk_type == RiskType.PERCENT_BALANCE:
            lot_calc = """
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = balance * RiskPercent / 100;
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double lotSize = riskAmount / (StopLoss * tickValue);
   
   // Normalize lot size
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   lotSize = MathMax(minLot, MathMin(maxLot, lotSize));
   lotSize = MathRound(lotSize / lotStep) * lotStep;
   
   return lotSize;"""
        else:
            lot_calc = "return 0.01;  // Default micro lot"
        
        return lot_calc
    
    def _combine_code_sections(self, header: str, indicator_code: Dict[str, str],
                              entry_logic: Dict[str, str], exit_logic: str,
                              risk_code: str, template_vars: Dict[str, Any]) -> str:
        """Combine all code sections into complete EA"""
        # Add includes
        includes = """
#include <Trade\\Trade.mqh>
#include <Trade\\PositionInfo.mqh>
#include <Trade\\OrderInfo.mqh>
#include <Trade\\SymbolInfo.mqh>

"""
        
        # Format globals section
        globals = self.templates["globals"].format(
            indicator_handles=indicator_code["handles"],
            indicator_buffers=indicator_code["buffers"]
        )
        
        # Format init section
        init = self.templates["init"].format(
            name=template_vars["name"],
            indicator_init=indicator_code["inits"]
        )
        
        # Format deinit section
        deinit = self.templates["deinit"].format(
            name=template_vars["name"],
            indicator_release=indicator_code["releases"]
        )
        
        # Format entry logic
        entry = self.templates["entry_logic"].format(
            get_indicator_values=indicator_code["get_values"],
            **entry_logic
        )
        
        # Format utility functions
        utilities = self.templates["utility_functions"].format(
            lot_calculation=risk_code,
            timeframe=template_vars["timeframe"]
        )
        
        # Combine all sections
        full_code = (
            includes + header + "\n" +
            globals + "\n" +
            init + "\n" +
            deinit + "\n" +
            self.templates["tick"] + "\n" +
            entry + "\n" +
            self.templates["position_management"] + "\n" +
            utilities
        )
        
        return full_code
    
    def _validate_syntax(self, code: str) -> List[str]:
        """Basic syntax validation"""
        errors = []
        
        # Check for balanced braces
        open_braces = code.count('{')
        close_braces = code.count('}')
        if open_braces != close_braces:
            errors.append(f"Unbalanced braces: {open_braces} open, {close_braces} close")
        
        # Check for required functions
        required_functions = ["OnInit", "OnDeinit", "OnTick"]
        for func in required_functions:
            if func not in code:
                errors.append(f"Missing required function: {func}")
        
        # Check for common syntax errors
        if ";;" in code:
            errors.append("Double semicolon detected")
        
        if "if(" not in code and "if (" not in code:
            errors.append("No conditional statements found")
        
        return errors
    
    def _generate_optimization_hints(self, params: StrategyParameters) -> List[str]:
        """Generate optimization suggestions"""
        hints = []
        
        # Check indicator parameters
        if any(cond.indicator == IndicatorType.RSI for cond in params.entry_conditions):
            hints.append("Consider optimizing RSI period (10-20) for better signals")
        
        # Check risk parameters
        if params.risk_value > 5:
            hints.append("High risk per trade. Consider reducing to 1-2%")
        
        # Check stop loss
        if params.stop_loss_pips and params.stop_loss_pips > 100:
            hints.append("Large stop loss. Consider tighter stops with better entry timing")
        
        # Check timeframe
        if params.timeframe in [TimeFrame.M1, TimeFrame.M5]:
            hints.append("Lower timeframes have more noise. Consider adding filters")
        
        return hints
    
    def _calculate_performance_score(self, params: StrategyParameters) -> float:
        """Calculate estimated performance score"""
        score = 50.0  # Base score
        
        # Bonus for multiple confirmation indicators
        indicator_count = len(set(cond.indicator for cond in params.entry_conditions))
        if indicator_count > 1:
            score += 10
        
        # Bonus for proper risk management
        if params.stop_loss_pips and params.take_profit_pips:
            if params.take_profit_pips > params.stop_loss_pips:
                score += 15
        
        # Bonus for reasonable risk
        if 0.5 <= params.risk_value <= 2:
            score += 10
        
        # Penalty for scalping without proper setup
        if params.timeframe in [TimeFrame.M1, TimeFrame.M5] and indicator_count < 2:
            score -= 10
        
        # Bonus for trend following in higher timeframes
        if params.type == StrategyType.TREND_FOLLOWING and params.timeframe in [TimeFrame.H4, TimeFrame.D1]:
            score += 15
        
        return max(0, min(100, score)) 